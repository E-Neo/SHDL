(define-module (shdl agenda)
  #:use-module (ice-9 q)
  #:export (make-agenda
            after-delay
            propagate
            step))


(define (make-time-segment time queue)
  (cons time queue))

(define (get-segment-time s) (car s))

(define (get-segment-queue s) (cdr s))

(define (make-new-time-segment time action)
  (let ((q (make-q)))
    (enq! q action)
    (make-time-segment time q)))

(define (make-agenda)
  (let ((agenda-data (list 0)))
    (define (get-current-time)
      (car agenda-data))
    (define (set-current-time! time)
      (set-car! agenda-data time))
    (define (get-segments)
      (cdr agenda-data))
    (define (set-segments! segments)
      (set-cdr! agenda-data segments))
    (define (get-first-segment)
      (car (get-segments)))
    (define (get-rest-segments)
      (cdr (get-segments)))
    (define (empty?)
      (null? (get-segments)))
    (define (add! time action)
      (define (belongs-before? segments)
        (or (null? segments)
            (< time (get-segment-time (car segments)))))
      (define (add-to-segments! segments)
        (if (= (get-segment-time (car segments)) time)
            (enq! (get-segment-queue (car segments)) action)
            (let ((rest (cdr segments)))
              (if (belongs-before? rest)
                  (set-cdr! segments
                            (cons (make-new-time-segment time action)
                                  (cdr segments)))
                  (add-to-segments! rest)))))
      (let ((segments (get-segments)))
        (if (belongs-before? segments)
            (set-segments! (cons (make-new-time-segment time action)
                                 segments))
            (add-to-segments! segments))))
    (define (get-first-item)
      (if (empty?)
          (error "Agenda is empty -- GET-FIRST-ITEM")
          (let ((first-seg (get-first-segment)))
            (set-current-time! (get-segment-time first-seg))
            (q-front (get-segment-queue first-seg)))))
    (define (remove-first-item!)
      (let ((q (get-segment-queue (get-first-segment))))
        (deq! q)
        (if (q-empty? q)
            (set-segments! (get-rest-segments)))))
    (define (after-delay delay action)
      (add! (+ delay (get-current-time))
            action))
    (define (propagate)
      (if (not (empty?))
          (let ((first-item (get-first-item)))
            (first-item)
            (remove-first-item!)
            (propagate))))
    (define (step)
      (if (empty?)
          (error "Agenda is empty -- STEP")
          (let ((first-item (get-first-item)))
            (first-item)
            (remove-first-item!))))
    (define (dispatch m)
      (cond ((eq? m 'get-current-time) get-current-time)
            ((eq? m 'set-current-time!) set-current-time!)
            ((eq? m 'get-segments) get-segments)
            ((eq? m 'set-segments!) set-segments!)
            ((eq? m 'get-first-segment) get-first-segment)
            ((eq? m 'get-rest-segments) get-rest-segments)
            ((eq? m 'empty?) empty?)
            ((eq? m 'add!) add!)
            ((eq? m 'get-first-item) get-first-item)
            ((eq? m 'remove-first-item!) remove-first-item!)
            ((eq? m 'after-delay) after-delay)
            ((eq? m 'propagate) propagate)
            ((eq? m 'step) step)
            (else (error "Unknown operation -- AGENDA" m))))
    dispatch))

(define (after-delay agenda delay action)
  ((agenda 'after-delay) delay action))

(define (propagate agenda)
  ((agenda 'propagate)))

(define (step agenda)
  ((agenda 'step)))
